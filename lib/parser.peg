{
    var T = require('./ast_types');

    function mk(thing, opts) {
        opts.type = thing;
        return opts;
    }

    function mkMemberAccess(variable, members) {
        var prev = mk(T.VARIABLE, {name: variable});
        members.forEach(function(m) {
            if (m.t === 'static') {
                prev = mk(T.STATIC_MEMBER, {
                    subject: prev,
                    member: m.name
                });
            } else {
                throw new Error("unknown member type!");
            }
        });
        return prev;
    }
}

//
// Script

Script
    = __ leader:Statements sections:NamedSection* {
        if (leader.length) {
            leader = mk(T.SECTION, { name: 'actions', body: leader });
            sections.unshift(leader);
        }
        return sections;
    }

NamedSection
    = label:SectionLabel body:Statements {
        return mk(T.SECTION, { name: label, body: body });
    }

SectionLabel
    = name:SectionLabelName ':' TERM {
        return name;
    }

SectionLabelName
    = $ 'inputs'
    / $ 'actions'

Statements
    = __ statements:(Statement)* {
        return statements;
    }

Statement
    = IfStatement
    / Directive

IfStatement
    = IfKeyword _ cond:ScriptExpression _ ThenKeyword __ body:Statements alt:ElseClause? EndKeyword TERM {
        return mk(T.IF, { condition: cond, consequent: body, alternate: alt || [] });
    }

ElseClause
    = ElseKeyword __ body:Statements {
        return body;
    }

Directive
    = name:ident _ args:DirectiveArgs? TERM {
        return mk(T.DIRECTIVE, {
            name: name,
            args: args || { positional: [], named: {} }
        });
    }

DirectiveArgs
    = n:DirectiveNamedArgs {
        return { positional: [], named: n };
    }
    / p:DirectivePositionalArgs n:(',' __ n:DirectiveNamedArgs)? {
        return { positional: p, named: n ? n[2] : {} };
    }
    
DirectivePositionalArgs
    = head:DirectivePositionalArg tail:(',' __ DirectivePositionalArg)* {
        var out = [head];
        for (var i = 0; i < tail.length; ++i) {
            out.push(tail[i][2]);
        }
        return out;
    }

DirectivePositionalArg
    = arg:ScriptExpression { return arg; }

DirectiveNamedArgs
    = head:DirectiveNamedArgPair tail:(',' __ DirectiveNamedArgPair)* {
        var out = {};
        out[head.key] = head.value;
        for (var i = 0; i < tail.length; ++i) {
            out[tail[i][2].key] = tail[i][2].value;
        }
        return out;
    }

DirectiveNamedArgPair
    = key:DirectiveNamedArgArgName ':' _ value:ScriptExpression {
        return { key: key, value: value };
    }

DirectiveNamedArgArgName
    = $( ident_start ident_rest* )

//
// Expression Parsing

ScriptExpression
    = Pipeline
    / PartialPipeline
    / Atom

Pipeline
    = head:Atom items:(__ '|' __ FunctionCall)+ {
        return mk(T.PIPELINE, {
            initial: head,
            pipeline: mk(T.PARTIAL_PIPELINE, {
                list: items.map(function(i) { return i[3]; })
            })
        });
    }

PartialPipeline
    = '|' __ head:FunctionCall tail:(__ '|' __ FunctionCall)* {
        return mk(T.PARTIAL_PIPELINE, {
            list: [head].concat(tail.map(function(i) { return i[3]; }))
        });
    }

//
// Template Parsing

FileTemplate
    = FileChunk*

FileChunk
    = Expansion
    / Raw

Expansion
    = EXPANSION_START __ exp:ScriptExpression __ EXPANSION_END { return exp; }

Raw
    = $( [^{] / '{' !'{' )+

//
// Atoms

Atom
    = a:FunctionCall _  { return a; }
    / a:Number _        { return a; }
    / a:UserDefault _   { return a; }
    / a:Variable _      { return a; }
    / a:String _        { return a; }
    / a:Symbol _        { return a; }
    / a:Array _         { return a; }

FunctionCall
    = name:ident '(' _ args:AtomList? ')' {
        return mk(T.CALL, {name: name, args: args || []});
    }

Number
    = n:Integer {
        return n;
    }

Integer
    = val:$( [1-9] [0-9]* ) { return parseInt(val, 10); }
    / $( '0'+ ) ![1-9] { return 0; }

UserDefault
    = '$' m:member+ {
        return mkMemberAccess('defaults', m);
    }

Variable
    = v:simple_variable m:member+ {
        return mkMemberAccess(v, m);
    }
    / v:simple_variable {
        return mk(T.VARIABLE, {name: v});
    }

String
    = '"' str:(StringItem*) '"' {
        if (str.length === 1 && typeof str[0] === 'string') {
            return str[0];
        } else {
            return mk(T.INTERPOLATED_STRING, {chunks: str});
        }
    }

StringItem
    = $( StringChar+ )
    / Expansion

StringChar
    = '\\n'     { return "\n"; }
    / '\\t'     { return "\t"; }
    / '\\"'     { return '"'; }
    / '\\\\'    { return "\\"; }
    / '{' !'{'  { return String.fromCharCode(123); /* workaround for pegjs bug */ }
    / [^\{\"]

Symbol
    = sym:$( SymbolAtom+ ) !':' {
        return mk(T.SYMBOL, {name: sym});
    }

SymbolAtom
    = SymbolChar / ':' &SymbolChar

SymbolChar
    = [a-z0-9\.\\/_-]i

Array
    = '[' _ items:AtomList? ']' {
        return mk(T.ARRAY_LITERAL, {items: items});
    }

AtomList
    = head:Atom _ tail:(',' _ Atom _)* {
        var out = [head];
        for (var i = 0; i < tail.length; ++i) {
            out.push(tail[i][2]);
        }
        return out;
    }

//
// Helpers

_
    = [ \t]*

__
    = IGNORE*

IGNORE
    = [ \t\r\n]+
    / COMMENT

NL
    = '\n'
    / '\r' '\n'?

COMMENT
    = '#' [^\r\n]*

TERM
    = _ &EndKeyword
    / _ COMMENT? !.
    / _ COMMENT? NL __

EXPANSION_START
    = '{{'

EXPANSION_END
    = '}}'

ident_start
    = [a-z]i

ident_rest
    = [a-z0-9_-]i

ident
    = !Keyword name:$( ident_start ident_rest* ) { return name; }

simple_variable
    = '$' name:$( [a-zA-Z_]i [a-zA-Z0-9_]* ) {
        return name;
    }

member
    = static_member

static_member
    = '.' name:$( ident_start ident_rest* ) {
        return { t: 'static', name: name };
    }

//
// Keywords

Keyword
    = IfKeyword
    / ThenKeyword
    / ElseKeyword
    / EndKeyword

IfKeyword       = 'if'      !ident_rest
ThenKeyword     = 'then'    !ident_rest
ElseKeyword     = 'else'    !ident_rest
EndKeyword      = 'end'     !ident_rest