{
    var T = require('./ast_types');

    function mk(thing, opts) {
        opts.type = thing;
        return opts;
    }
}

//
// Helpers
_
    = [ \t]*

__
    = IGNORE*

IGNORE
    = [ \r\n\t]+
    / COMMENT

START
    = '{{'

END
    = '}}'

NL
    = '\n'
    / '\r' '\n'?

COMMENT
    = '#' [^\r\n]*

ident_start
    = [a-z]i

ident_rest
    = [a-z0-9_-]i

ident
    = !Keyword name:$( ident_start ident_rest* ) { return name; }

//
// Keywords

Keyword
    = IfKeyword
    / ElseKeyword
    / EndKeyword

IfKeyword       = 'if'      !ident_rest
ElseKeyword     = 'else'    !ident_rest
EndKeyword      = 'end'     !ident_rest

//
// Expression Parsing

ScriptExpression
    = Pipeline
    / PartialPipeline
    / Atom

Pipeline
    = head:Atom pipeline:PartialPipeline {
        return mk(T.PIPELINE, {
            initial: head,
            pipeline: pipeline
        });
    }

PartialPipeline
    = items:('|' _ FunctionCall _)+ {
        return mk(T.PARTIAL_PIPELINE, {
            list: items.map(function(i) {
                return i[2]
            })
        });
    }

Atom
    = a:FunctionCall _  { return a; }
    / a:Number _        { return a; }
    / a:Variable _      { return a; }
    / a:String _        { return a; }
    / a:Predicate _     { return a; }
    / a:Symbol _        { return a; }
    / a:Array _         { return a; }

FunctionCall
    = name:ident '(' _ args:AtomList? ')' {
        return mk(T.CALL, {name: name, args: args || []});
    }

Number
    = n:Integer {
        return n;
    }

Integer
    = val:$( [1-9] [0-9]* ) { return parseInt(val, 10); }

Variable
    = '$' name:$( [a-zA-Z_]i [a-zA-Z0-9_]* ) {
        return mk(T.VARIABLE, {name: name});
    }

Predicate
    = sym:Symbol '?' {
        return mk(T.PREDICATE, {name: sym.name});
    }

Symbol
    = sym:$( SymbolAtom+ ) !':' {
        return mk(T.SYMBOL, {name: sym});
    }

SymbolAtom
    = SymbolChar / ':' &SymbolChar

SymbolChar
    = [a-z0-9\.\\/_-]i

Array
    = '[' _ items:AtomList? ']' {
        return mk(T.ARRAY, {items: items});
    }

AtomList
    = head:Atom _ tail:(',' _ Atom _)* {
        var out = [head];
        for (var i = 0; i < tail.length; ++i) {
            out.push(tail[i][2]);
        }
        return out;
    }

Expansion
    = START __ exp:ScriptExpression END { return exp; }

String
    = '"' str:(StringItem*) '"' {
        if (str.length === 1 && typeof str[0] === 'string') {
            return str[0];
        } else {
            return mk(T.INTERPOLATED_STRING, {chunks: str});
        }
    }

StringItem
    = $( StringChar+ )
    / Expansion

StringChar
    = '\\n'     { return "\n"; }
    / '\\t'     { return "\t"; }
    / '\\"'     { return '"'; }
    / '\\\\'    { return "\\"; }
    / '{' !'{'  { return String.fromCharCode(123); /* workaround for pegjs bug */ }
    / [^\{\"]
